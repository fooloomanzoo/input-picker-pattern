<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>switch-mixin test</title>

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/mock-interactions.js"></script>
    <script src="../utils/wct-mixin-test-helper.js"></script>

    <link rel="import" href="elements/basic-switch-element.html">
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <basic-switch-element></basic-switch-element>
      </template>
    </test-fixture>

    <script>
      WCT.helpers.mixinSuite('basic-switch-element');

      suite('basic', function() {
        let element;

        setup(function() {
          element = fixture('Basic');
        });

        test('instantiating the element with default properties works', done => {
          assert.isDefined(element.dwellTime);
          assert.isDefined(element._switchClassSelector);
          done();
        });
      });

      suite('basic interactions', function() {
        let element, switches;

        setup(function() {
          element = fixture('Basic');
        });

        test('basic', done => {
          setTimeout(function() {
            switches = element.shadowRoot.querySelectorAll('.' + element._switchClassSelector);
            assert.isOk(switches && switches.length, 'there should be switches');
            done();
          }, 0);
        });

        test('prop attributes', done => {
          setTimeout(function() {
            switches = element.shadowRoot.querySelectorAll('.' + element._switchClassSelector);
            // wait a tick to let all property effects to take place
            assert.isTrue(Array.prototype.every.call(switches, s => s.hasAttribute('prop')), 'every switch should have an prop attribute');
            done();
          }, 0);
        });

        test('step attribute', done => {
          setTimeout(function() {
            switches = element.shadowRoot.querySelectorAll('.' + element._switchClassSelector);
            // wait a tick to let all property effects to take place
            assert.isTrue(Array.prototype.every.call(switches, s => s.hasAttribute('step')), 'every switch should have an step attribute');
            done();
          }, 0);
        });

        test('incrementing an initialized property', done => {
          setTimeout(function() {
            switches = element.shadowRoot.querySelectorAll('.' + element._switchClassSelector);
            for (let i = 0; i < switches.length; i++) {
              let prop = switches[i].getAttribute('prop');
              let step = +switches[i].getAttribute('step');
              let invert = switches[i].hasAttribute('invert') ? -1 : 1;
              element[prop] = step;
              // there might be a resetting by clamping
              const value = element[prop];
              MockInteractions.tap(switches[i]);
              if (invert * step < 0) {
                if (element[prop] === 0 && value === 0) {
                  assert.isBelow(1/element[prop], 1/value, prop + ': switch should increment by ' + step);
                } else {
                  assert.isBelow(element[prop], value, prop + ': switch should increment by ' + step);
                }
              } else {
                if (element[prop] === 0 && value === 0) {
                  assert.isAbove(1/element[prop], 1/value, prop + ': switch should increment by ' + step);
                } else {
                  assert.isAbove(element[prop], value, prop + ': switch should increment by ' + step);
                }
              }
            }
            done();
          }, 0);
        });

        test('incrementing an uninitialized property', done => {
          setTimeout(function() {
            switches = element.shadowRoot.querySelectorAll('.' + element._switchClassSelector);
            for (let i = 0; i < switches.length; i++) {
              let prop = switches[i].getAttribute('prop');
              MockInteractions.tap(switches[i]);
              assert.isNotNaN(element[prop], prop + ': property should be defined');
              element[prop] = undefined; // resetting property for other switches to test
            }
            done();
          }, 0);
        });

        test('incrementing an pressing enter-key', done => {
          setTimeout(function() {
            switches = element.shadowRoot.querySelectorAll('.' + element._switchClassSelector);
            for (let i = 0; i < switches.length; i++) {
              let prop = switches[i].getAttribute('prop');
              let step = +switches[i].getAttribute('step');
              let invert = switches[i].hasAttribute('invert') ? -1 : 1;
              element[prop] = step;
              // there might be a resetting by clamping
              const value = element[prop];
              MockInteractions.pressAndReleaseKeyOn(switches[i], 32);
              if (invert * step < 0) {
                if (element[prop] === 0 && value === 0) {
                  assert.isBelow(1/element[prop], 1/value, prop + ': switch should increment by ' + step);
                } else {
                  assert.isBelow(element[prop], value, prop + ': switch should increment by ' + step);
                }
              } else {
                if (element[prop] === 0 && value === 0) {
                  assert.isAbove(1/element[prop], 1/value, prop + ': switch should increment by ' + step);
                } else {
                  assert.isAbove(element[prop], value, prop + ': switch should increment by ' + step);
                }
              }
            }
            done();
          }, 0);
        });

        test('incrementing an pressing space-key', done => {
          setTimeout(function() {
            switches = element.shadowRoot.querySelectorAll('.' + element._switchClassSelector);
            for (let i = 0; i < switches.length; i++) {
              let prop = switches[i].getAttribute('prop');
              let step = +switches[i].getAttribute('step');
              let invert = switches[i].hasAttribute('invert') ? -1 : 1;
              element[prop] = step;
              // there might be a resetting by clamping
              const value = element[prop];
              MockInteractions.pressAndReleaseKeyOn(switches[i], 13);
              if (invert * step < 0) {
                if (element[prop] === 0 && value === 0) {
                  assert.isBelow(1/element[prop], 1/value, prop + ': switch should increment by ' + step);
                } else {
                  assert.isBelow(element[prop], value, prop + ': switch should increment by ' + step);
                }
              } else {
                if (element[prop] === 0 && value === 0) {
                  assert.isAbove(1/element[prop], 1/value, prop + ': switch should increment by ' + step);
                } else {
                  assert.isAbove(element[prop], value, prop + ': switch should increment by ' + step);
                }
              }
            }
            done();
          }, 0);
        });
      });

      suite('interactions by holding', function() {
        let f, switchSpecifiers;

        setup(function() {
          f = fixture('Basic');
        })

        test('each switch', Done => {
          setTimeout(function() {
            // wait a tick to let all property effects to take place

            switchSpecifiers = [];
            Array.prototype.forEach.call(f.shadowRoot.querySelectorAll('.' + f._switchClassSelector), s => {
              switchSpecifiers.push({
                step: +s.getAttribute('step'),
                prop: s.getAttribute('prop'),
                invert: (s.hasAttribute('invert') ? -1 : 1)
              });
            })
            // set dwellTime to not run into timeout
            let dwellTime = 15, dwellDelay = 15;
            for (let i = 0; i < switchSpecifiers.length; i++) {
              let specifier = switchSpecifiers[i];
              // create new suite for each switch, so that there no interferences when changing propeties
              suite('interactions by holding for ' + specifier.prop, function() {
                let element;

                setup(function() {
                  element = fixture('Basic');
                  element.dwellTime = dwellTime;
                  element.dwellDelay = dwellDelay;
                });

                test('incrementing by holding', done => {
                  // wait a tick to let all property effects to take place
                  setTimeout(function() {
                    // find the switch that was found earlier, to test it in this suite
                    let prop = specifier.prop,
                      invert = specifier.invert,
                      step = specifier.step;
                    let s = Array.prototype.find.call(element.shadowRoot.querySelectorAll('.' + element._switchClassSelector), sw => (step === +sw.getAttribute('step') && prop === sw.getAttribute('prop') && invert === (sw.hasAttribute('invert') ? -1 : 1)));
                    assert.isOk(s, 'the switch should be available');
                    // defaulting the prop
                    const value = element[prop];
                    MockInteractions.down(s);
                    setTimeout(() => {
                      assert.equal(s, element._activeSwitch, 'active switch should be the holded switch');
                      assert.isTrue(s.hasAttribute('active'), 'holded switch should have the attribute \'active\'');
                      MockInteractions.up(s);
                      assert.notEqual(s, element._activeSwitch, 'active switch should not be the holded switch when being released');
                      assert.isFalse(s.hasAttribute('active'), 'holded switch should not have the attribute \'active\' when being released');
                      assert.notEqual(element[prop], value, prop + ': switch should increment by ' + step);
                      done();
                    }, element.dwellDelay + element.dwellTime*1.75); // calling increment maximal twice
                  }, 0)
                });
              });
            }
            Done();
          }, 0)
        })
      });
    </script>

  </body>
</html>
