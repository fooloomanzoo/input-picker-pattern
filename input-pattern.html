<link rel="import" href="form-element-mixin.html">
<link rel="import" href="input-shared-style.html">

<script>
  /**
   * Mixin to extend an element that includes a native input to be wrapped. The pattern is using `input-shared-style` to unify the style between different inputs and should resize according to its properties and input.
   *
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   */
  const InputPattern = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends FormElementMixin(superClass) {  // eslint-disable-line no-undef

      constructor() {
        super();
        this.focus = this.focus.bind(this);
        this.blur = this.blur.bind(this);
        this.resize = this.resize.bind(this);
        this._updateInput = this._updateInput.bind(this);
        this._confirmInput = this._confirmInput.bind(this);
        this._checkKeycode = this._checkKeycode.bind(this);
        this._computeWidth = this._computeWidth.bind(this);
      }

      static get template() {
        return `
          <style include="${this.styleToInclude}">
            ${this.styleTemplate}
          </style>
          ${this.inputTemplate}
          <div id="size">[[input]]</div>
          <div id="minsize">[[_minWidthString]]</div>
        `;
      }

      static get styleToInclude() {
        return 'input-shared-style';
      }

      static get styleTemplate() {
        return `
          ${super.styleTemplate || ''}
          :host {
            display: inline-flex;
            justify-content: center;
            box-sizing: content-box;
          }
          #minsize,
          #size {
            position: fixed;
            top: 0; left: 0; right: auto; bottom: auto;
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            font-style: inherit;
            outline: none;
            line-height: normal;
            box-sizing: content-box;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
            padding: 0 !important;
            margin: 0;
            min-width: inherit;
            max-width: inherit;
            border: var(--input-border-width, thin) solid transparent;
            @apply --input-style;
          }
          #input {
            box-sizing: content-box;
            width: 0;
          }
        `;
      }

      /**
      * @overwrite
      * this input-template is suposed to be overwritten to a custon implementation
      * NOTE: '@fooloomanzoo/text-input' implements also pattern validation
      */
      static get inputTemplate() {
        return `
          <input id="input"
            type="[[type]]"
            value="{{input::input}}"
            placeholder="[[placeholder]]"
            required$="[[required]]"
            disabled$="[[disabled]]"
            spellcheck="false"
            autocomplete="off">
        `;
      }

      static get properties() {
        return {
          /**
           * the type of the native input
           */
          type: {
            type: String,
            value: 'text'
          },

          /**
           * the immediate input string
           */
          input: {
            type: String,
            notify: true,
            observer: '_inputChanged'
          },

          /**
           * the placeholder string
           */
          placeholder: {
            type: String
          },

          /**
           * the minlength of the input
           */
          minlength: {
            type: Number
          },

          /**
           * if true, the width will change when typing
           */
          autoResize: {
            type: Boolean,
            observer: '_debouncedComputeWidth'
          },

          /**
           * string that is used to compute the minimal width of the input
           */
          _minWidthString: {
            type: String
          },

          /**
           * if `true`, the input is not displayed
           */
          hidden: {
            type: Boolean
          }
        }
      }

      static get observers() {
        return [
          '_computeInvalid(input, required)',
          '_computeValueIsSet(input)',
          '_computeMinWidth(minlength, default, placeholder)',
          'resize(_minWidthString, hidden)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this._addEventListeners();
        setTimeout(this.resize, 0);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removeEventListeners();
      }

      _addEventListeners() {
        this.addEventListener('focus', this.focus, false);
        this.addEventListener('blur', this.blur, false);
        this.$.input.addEventListener('focus', this._confirmInput, false);
        this.$.input.addEventListener('blur', this._confirmInput, false);
        this.$.input.addEventListener('keydown', this._checkKeycode, false);
      }

      _removeEventListeners() {
        this.removeEventListener('focus', this.focus, false);
        this.removeEventListener('blur', this.blur, false);
        this.$.input.removeEventListener('focus', this._confirmInput, false);
        this.$.input.removeEventListener('blur', this._confirmInput, false);
        this.$.input.removeEventListener('keydown', this._checkKeycode, false);
      }

      _checkKeycode(e) {
        super._checkKeycode && super._checkKeycode(e);
        switch (e.keyCode) {
          case 9: // tab
          case 13: // enter
            this._confirmInput();
            break;
          case 27: // esc
            this._updateInput();
            e.stopPropagation();
            this.blur();
            break;
        }
      }

      _inputChanged(input) {
        // test if value is set and if needed set input to default
        if (this._isSet(input) === false && this.default !== undefined) {
          this.input = this.default;
          return;
        }
        if (this.autoResize) {
          this._debouncedComputeWidth();
        }
      }

      _valueChanged(value) {
        super._valueChanged(value);
        // always update the input
        this._updateInput();
      }

      _confirmInput(e) {
        // update the value, when input validates
        if (this._validate(this.input)) {
          this.value = this.input;
        } else {
          // else reset the input to value
          this.input = this.value;
        }
        this._debouncedComputeWidth();
        e && e.stopPropagation && e.stopPropagation();
      }

      _updateInput(e) {
        this.input = this.value;
        this._debouncedComputeWidth();
        e && e.stopPropagation && e.stopPropagation();
      }

      _computeMinWidth() {
        const def = this.default || '',
          placeholder = this.placeholder || '',
          minlength = this.minlength || 1,
          charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; // to compute a random string for minlength to estemate usage of space
        let minlengthString = '';
        for (let i = 0; i < minlength; i++) {
          minlengthString += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        this._minWidthString = [placeholder, minlengthString].reduce( (acc, curr) => {
          return curr.length > acc.length ? curr : acc;
        }, def);
      }

      /**
       * called automatically when static `_minWidthString` changes, but can called manually to resize the minwidth of the input, when the input is for example initially hidden
       */
      resize() {
        if (!this._minWidthString || this.hidden || this._minSizeJob) {
          return;
        }
        this._minSizeJob = requestAnimationFrame( () => {
          let width = this.$.minsize.getBoundingClientRect().width;
          // measure the width of the test element
          if (width !== 0) {
            this.$.input.style.minWidth = `${width}px`;
            this._debouncedComputeWidth();
            this._minSizeJob = null;
          } else {
            // if that fails, clone the test node to document level and add some basic styles, that could define the elements's width
            const minsizeClone = this.$.minsize.cloneNode(true);
            const style = document.defaultView.getComputedStyle(this.$.minsize, '');
            ['font-family', 'font-size', 'font-weight', 'font-style', 'letter-spacing', 'min-width', 'max-width'].reduce(
              ( accumulator, currentValue) => {
                if (currentValue && style[currentValue]) {
                  minsizeClone.style[currentValue] = style[currentValue];
                }
              }, 'font-family');
            minsizeClone.style.display = 'inline-flex';
            minsizeClone.style.opacity = '0';
            minsizeClone.style.position = 'fixed';
            minsizeClone.style.left = '0';
            minsizeClone.style.top = '0';
            minsizeClone.style.border = 'thin solid transparent';

            document.body.appendChild(minsizeClone);
            requestAnimationFrame( () => {
              width = minsizeClone.getBoundingClientRect().width;
              minsizeClone.parentElement.removeChild(minsizeClone);
              this._minSizeJob = null;
              if (width !== 0) {
                this.$.input.style.minWidth = `${width}px`;
                this._debouncedComputeWidth();
              } else {
                // if it fails again, retry
                this.resize();
              }
            });
          }
        })

      }

      _debouncedComputeWidth() {
        if (this._activeResizeJob) {
          clearTimeout(this._activeResizeJob);
        }
        this._activeResizeJob = setTimeout(this._computeWidth, 0);
      }

      _computeWidth() {
        this.$.input.style.width = `${this.$.size.getBoundingClientRect().width}px`;
      }

      /**
       * focus the input
       */
      focus(e) {
        super.focus(e);
        this.$.input.focus();
        this.$.input.scrollIntoViewIfNeeded && this.$.input.scrollIntoViewIfNeeded();
      }

      /**
       * focus the input
       */
      blur(e) {
        super.blur(e);
        this.$.input.blur();
      }

    }
  }

  window.InputPattern = InputPattern;
</script>
