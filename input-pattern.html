<link rel="import" href="../polymer/lib/utils/mixin.html">
<link rel="import" href="form-element-mixin.html">
<link rel="import" href="input-shared-style.html">

<script>
  /**
   * resize the width of a node by a relative node
   * @param  {Node} node      the node to apply the sizing attribute of the relative node to the width
   * @param  {Node} relative  the node to get the sizing information from
   * @param  {String} attrToSet the attribute to set on the node
   */
  function resizeWidthByRelative(node, relative, attrToSet) {
    // measure the width of the test element
    let width = relative.getBoundingClientRect().width;
    if (width !== 0) {
      node.style[attrToSet] = `${width.toFixed(1)}px`;
    } else {
      // if that fails, it could be, that the element is hidden
      // therefore clone the node to document level and add some basic styles, that could define the elements's width
      const relativeClone = relative.cloneNode(true);
      const style = document.defaultView.getComputedStyle(relative, '');
      ['font-family', 'font-size', 'font-weight', 'font-style', 'min-width', 'max-width'].reduce(
        ( accumulator, currentValue) => {
          if (currentValue && style[currentValue]) {
            relativeClone.style[currentValue] = style[currentValue];
          }
        }, 'letter-spacing');
      relativeClone.style.visibility = 'hidden';
      relativeClone.style.position = 'fixed';
      relativeClone.style.left = '0';
      relativeClone.style.top = '0';
      document.body.appendChild(relativeClone);
      width = relativeClone.getBoundingClientRect().width;
      relativeClone.parentElement.removeChild(relativeClone);
      node.style[attrToSet] = `${width.toFixed(1)}px`;
    }
  }

  /**
   * Mixin to extend an element that includes a native input to be wrapped to enable content-based resizing and validation. The pattern is using `input-shared-style` to unify the style between different inputs and should resize according to its properties and input.
   *
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   */
  const InputPattern = function(superClass) { // eslint-disable-line no-unused-vars

    return class extends FormElementMixin(superClass) {  // eslint-disable-line no-undef

      constructor() {
        super();
        this.focus = this.focus.bind(this);
        this.blur = this.blur.bind(this);
        this.resize = this.resize.bind(this);
        this._updateInput = this._updateInput.bind(this);
        this._confirmInput = this._confirmInput.bind(this);
        this._checkKeycode = this._checkKeycode.bind(this);
        this._resizeWidth = this._resizeWidth.bind(this);
      }

      static get template() {
        return `
          <style include="${this.styleToInclude}">
            ${this.styleTemplate}
          </style>
          ${this.inputTemplate}
          <span id="size">[[input]]</span>
          <span id="minlength">[[_minlengthString]]</span>
        `;
      }

      static get styleToInclude() {
        return 'input-shared-style';
      }

      static get styleTemplate() {
        return `
          ${super.styleTemplate || ''}
          #input {
            width: 0;
          }
          #minlength,
          #size {
            position: fixed;
            top: 0; left: 0; right: auto; bottom: auto;
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            font-style: inherit;
            letter-spacing: inherit;
            outline: none;
            min-width: inherit;
            max-width: inherit;
            margin: 0;
            padding: 0;
            visibility: hidden;
          }
        `;
      }

      /**
      * @overwrite
      * this input-template is suposed to be overwritten to a custon implementation
      * NOTE: '@fooloomanzoo/text-input' implements also pattern validation
      */
      static get inputTemplate() {
        return `
          <input id="input"
            type="[[type]]"
            value="{{input::input}}"
            placeholder="[[placeholder]]"
            required$="[[required]]"
            disabled$="[[disabled]]"
            title$="[[title]]"
            spellcheck="false"
            autocomplete="off">
        `;
      }

      static get properties() {
        return {
          /**
           * the type of the native input
           */
          type: {
            type: String,
            value: 'text'
          },

          /**
           * the immediate input string
           */
          input: {
            type: String,
            notify: true,
            observer: '_inputChanged'
          },

          /**
           * message to set on the input to show if the input does not validate
           */
          validationMessage: {
            type: String,
            observer: 'setCustomValidity'
          },

          /**
           * the placeholder string
           */
          placeholder: {
            type: String
          },

          /**
           * the minlength of the input
           */
          minlength: {
            type: Number
          },

          /**
           * if true, the width will change when typing
           */
          autoResize: {
            type: Boolean,
            observer: '_debouncedResizeWidth'
          },

          /**
           * string that is used to compute the minimal width of the input
           */
          _minlengthString: {
            type: String
          }
        }
      }

      static get observers() {
        return [
          '_computeInvalid(input, required)',
          '_computeMinlengthString(minlength, default, placeholder)',
          'resize(_minlengthString)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this._addEventListeners();
        if (this.input && this.input.length) {
          this._debouncedResizeWidth();
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removeEventListeners();
      }

      _addEventListeners() {
        this.addEventListener('focus', this.focus, false);
        this.addEventListener('blur', this.blur, false);
        this.$.input.addEventListener('focus', this._confirmInput, false);
        this.$.input.addEventListener('blur', this._confirmInput, false);
        this.$.input.addEventListener('keydown', this._checkKeycode, false);
      }

      _removeEventListeners() {
        this.removeEventListener('focus', this.focus, false);
        this.removeEventListener('blur', this.blur, false);
        this.$.input.removeEventListener('focus', this._confirmInput, false);
        this.$.input.removeEventListener('blur', this._confirmInput, false);
        this.$.input.removeEventListener('keydown', this._checkKeycode, false);
      }

      _checkKeycode(e) {
        super._checkKeycode && super._checkKeycode(e);
        switch (e.keyCode) {
          case 9: // tab
          case 13: // enter
            this._confirmInput();
            break;
          case 27: // esc
            this._updateInput();
            this.blur();
            break;
        }
      }

      _inputChanged(input) {
        // test if value is set and if needed set input to default
        if (this._isSet(input) === false && this.default !== undefined) {
          this.input = this.default;
          return;
        }
        if (this.autoResize) {
          this._debouncedResizeWidth();
        }
      }

      _valueChanged(value) {
        super._valueChanged(value);
        // always update the input
        this._updateInput();
      }

      /**
       * update manually the value with the native input
       */
      _confirmInput(e) {
        // update the value, when input validates
        if (this._validate(this.input)) {
          this.value = this.input;
          this._debouncedResizeWidth();
          e && e.stopPropagation && e.stopPropagation();
        } else {
          // else reset the input to value
          this._updateInput(e);
        }
      }

      /**
       * update manually the native input with the given value
       */
      _updateInput(e) {
        if (this._isSet(this.value)) {
          this.input = this.value;
        } else {
          this.input = '';
        }
        this._debouncedResizeWidth();
        e && e.stopPropagation && e.stopPropagation();
      }

      /**
       * compute the minimal string the input is sized for
       */
      _computeMinlengthString() {
        const def = '' + (this.default || ''),
          placeholder = '' + (this.placeholder || ''),
          minlength = this.minlength < 1 ? 1 : this.minlength,
          charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; // to compute a random string for minlength to estemate usage of space
        let minlengthString = '';
        for (let i = 0; i < minlength; i++) {
          minlengthString += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        this._minlengthString = [placeholder, minlengthString].reduce( (acc, curr) => {
          return curr.length > acc.length ? curr : acc;
        }, def);
      }

      /**
       * called automatically when static `_minlengthString` or visibilityState changes, but can be called manually to resize the minwidth of the input, when the input is for example initially hidden
       */
      resize() {
        // compute minimal width of the input
        if (this._minSizeJob) {
          clearTimeout(this._minSizeJob);
        }
        if (this._minlengthString) {
          this._minSizeJob = setTimeout(resizeWidthByRelative(this.$.input, this.$.minlength, 'minWidth'), 0);
        }
        // compute width of the input
        if (this.input && this.input.length) {
          this._debouncedResizeWidth();
        }
      }

      _debouncedResizeWidth() {
        if (this._activeResizeJob) {
          clearTimeout(this._activeResizeJob);
        }
        this._activeResizeJob = setTimeout(this._resizeWidth, 0);
      }

      _resizeWidth() {
        resizeWidthByRelative(this.$.input, this.$.size, 'width');
      }

      /**
       * focus the input element
       */
      focus(e) {
        super.focus(e);
        this.$.input.focus();
        this.$.input.scrollIntoViewIfNeeded && this.$.input.scrollIntoViewIfNeeded();
      }

      /**
       * removes focus from input
       */
      blur(e) {
        super.blur(e);
        this.$.input.blur();
      }

      /**
       * selects the input text in the element, and focuses it so the user can subsequently replace the whole entry
       */
      select() {
        this.$.input.select();
      }

      /**
       * simulates a click on the element
       */
      click() {
        this.$.input.click();
      }

      /**
       * sets on the native input a validity message
       * @param {String} msg   the message to set
       */
      setCustomValidity(msg) {
        this.$.input.setCustomValidity(msg || '');
      }

      /**
       * reports the validity state of the native input
       * @return {Boolean}  validity state
       */
      reportValidity() {
        return this.$.input.reportValidity();
      }

    }
  }

  window.InputPattern = Polymer.dedupingMixin(InputPattern);
</script>
